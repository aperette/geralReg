{
    "collab_server" : "",
    "contents" : "#' @title  Normal regression model with general parametrization\n#'\n#' @description Determine the estimates of the parameters of a\n#' general parametrization model with a Newthon Raphson method\n#'\n#'\n#' @param formula a nonlinear model formula including variables and parameters\n#' @param formula_var a nonlinear model formula for the diagonal of covariance matrix\n#' @param data A data frame in which to evaluate the variables in \\code{formula} and \\code{formula_var}.\n#' Can also be a list or an environment, but not a matrix\n#' @param theta_ini A named list of starting estimates. When \\code{start} is missing, a very cheap guess for \\code{start} is tried and parameters names are automatically identified\n#' @param control A list of control parameters. See 'Details'\n#' @param bias_correction Logical. Should a bias correction be estimated for the parameters?\n#'\n#'\n#' @details The control argument is a list that can supply any of the following components:\n#'  \\itemize{\n#'  \\item max_it Maximum number of iterations\n#'  \\item parada Maximum difference between iterations to consider convergence\n#'}\n#'\n#'  @examples\n#' \\dontrun{\n#'\n#' fit <- reg_geral(y~alfa+X1^(gama)+beta*X2,~100+sigma*X3,data=data,\n#' theta_ini=list(alfa=100,beta=1,gama=0.5,sigma=0.1),bias_correction = T)\n#'\n#' }\n#'\n#' @export\n\n\nreg_geral=function(formula=NULL,\n                   formula_var=NULL,\n                   mu=NULL,\n                   S=NULL,\n                   data,\n                   resposta=NULL,\n                   theta_ini=NULL,\n                   max_it=50,\n                   parada=0.01,\n                   bias_correction=T){\n\n  if(!is.null(formula)){\n    if(!inherits(formula,\"formula\"))\n      stop(\"formula has a indefinite format\",call. = F)}\n  if(!is.null(formula_var)){\n    if(!inherits(formula_var,\"formula\"))\n    stop(\"formula_var has a indefinite format\",call. = F)}\n  if(is.null(formula) & is.null(mu)){\n    stop('arguments \"formula\" and \"mu\" are missing, with no default',call. = F)}\n  if(is.null(formula_var) & is.null(S)){\n    stop('arguments \"formula_var\" and \"S\" are missing, with no default',call. = F)}\n  if(!is.null(theta_ini)){\n    if(!is.list(theta_ini))\n      stop(\"theta_ini must be a list\")\n    theta=names(theta_ini)}\n\n  if(!is.null(formula)){\n    resposta=data[,as.character(formula)[2]]\n    mu=as.character(formula)[3]\n  }\n  if(!is.null(formula_var)){\n    S=tail(as.character(formula_var),1)\n  }\n\n  cl <- match.call()\n  n=nrow(data)\n  q=1\n  par=definir_parametros(c(mu,S),data)\n  covar=par[[1]]\n  if(is.null(theta_ini))\n    theta=par[[2]]\n\n  cat(\"Parametros do modelo:\",paste0(theta,collapse=\", \"),\"\\n\")\n  cat(\"Covariaveis do modelo:\",paste0(covar,collapse=\",\"),\"\\n\")\n\n  Di=array()\n  Vi=array()\n  a=matrix(NA,nrow=length(theta),ncol=length(theta))\n  C=matrix(NA,nrow=length(theta),ncol=length(theta))\n  for(k in 1:length(theta)){\n    Di[k]=as.character(Deriv::Deriv(mu,theta[k]))\n    Vi[k]=as.character(Deriv::Deriv(S,theta[k]))\n    for(j in 1:length(theta)){\n      a[k,j]=as.character(Deriv::Deriv(Di[k],theta[j]))\n      C[k,j]=as.character(Deriv::Deriv(Vi[k],theta[j]))}\n  }\n\n  Fi=rbind(Di,Vi)\n  aC=rbind(c(a),c(C))\n\n  eval(parse(text=paste0(\n    \"gerar_mu = function(theta, data,N=n){ c(\",\n    paste(\"rep(1,N)*\",estruturar(mu,par),collapse = \",\")\n    ,\")}\"\n  )))\n\n  eval(parse(text=paste0(\n    \"gerar_sigma = function(theta, data,N=n){ Matrix::.sparseDiagonal(x=c(\",\n    paste(\"rep(1,N)*\",estruturar(S,par),collapse = \",\"),\n    \"),n=N)}\"\n  )))\n\n  eval(parse(text=paste0(\n    \"gerar_D = function(theta, data, N=n){Matrix::Matrix(c(\",\n    paste(\"rep(1,N)*\",estruturar(t(Di),par),collapse = \",\"),\n    \"), ncol=N,byrow=T) %>% as.vector %>% Matrix::Matrix(ncol=\",\n    length(theta),\", sparse=T,byrow=T)}\"\n  )))\n\n  gerar_J = function(D){\n    dt=dplyr::tibble(valor=as.vector(D),\n                     id=rep(1:nrow(D),ncol(D)),\n                     par=rep(1:ncol(D),each=nrow(D)))\n    dt2=dplyr::left_join(dt,dt,by=\"id\") %>%\n      dplyr::mutate(total=2*valor.x*valor.y,\n                    aux=1) %>%\n      dplyr::select(-valor.x,-valor.y)\n    dplyr::bind_rows(dt2,dt2 %>% dplyr::mutate(aux=0, total=0)) %>%\n      dplyr::arrange(par.x,par.y,id,aux) %>%\n      .$total %>%\n      Matrix::Matrix(nrow=2*nrow(D),sparse=T)\n  }\n\n  eval(parse(text=paste0(\n    \"gerar_G = function(theta, data,N=n){ Matrix::Matrix(c(\",\n    paste(\"rep(1,N)*\",estruturar(t(aC),par),collapse = \",\"),\n    \"), ncol=N,byrow=T) %>% as.vector %>% Matrix::Matrix(ncol=\",\n    ncol(aC),\", sparse=T,byrow=T)}\"\n  )))\n\n  eval(parse(text=paste0(\n    \"gerar_F = function(theta, data,N=n){ Matrix::Matrix(c(\",\n    paste(\"rep(1,N)*\",estruturar(Matrix::t(Fi),par),collapse = \",\"),\n    \"), ncol=N,byrow=T) %>% as.vector %>% Matrix::Matrix(ncol=\",\n    ncol(Fi),\", sparse=T,byrow=T)}\"\n  )))\n\n  correcao_vies=function(n_sample = 0.01){\n\n    D=gerar_D(theta_val,data)\n    G=gerar_G(theta_val,data)\n    J=gerar_J(D)\n\n    phi=-0.5*(G+J)\n\n    K=solve(Matrix::t(Fn)%*%Hn%*%Fn,tol=1e-2000)\n    e=phi%*%as.vector(K)\n\n    K%*%Matrix::t(Fn)%*%Hn%*%e}\n\n  gerar_H = function(sigma){\n    Matrix::diag(sigma) %>%\n    {rbind(1/.,0.5*(.^-2))} %>%\n      as.vector() %>%\n      {Matrix::.sparseDiagonal(x=.,n=length(.))}\n  }\n\n\n  gerar_s=function(media,sigma,theta){\n    res=resposta-media\n    s2=-(Matrix::diag(sigma)-res^2)\n    s=c(rbind(res,s2))\n    S=Fn %*% unlist(theta) + s\n    return(S)}\n\n\n  # gerar_H.multi = function(sigma){\n  #   seq(1,n,q) %>% lapply(function(x){\n  #     y=as.matrix(sigma[x:(x+q-1),x:(x+q-1)])\n  #     solve(Matrix::bdiag(list(y,Matrix::kronecker(2*y,y))))}) %>%\n  #     Matrix::bdiag()\n  # }\n\n  # gerar_s.multi=function(resp,media,sigma,theta){\n  #   res=resp-media\n  #   s=seq(1,n,q) %>% lapply(function(x){\n  #     y=sigma[x:(x+q-1),x:(x+q-1)]\n  #     z=res[x:(x+q-1)]\n  #     c(z,-(y-z%*%t(z)))\n  #     }) %>%\n  #     unlist()\n  #   Fn %*% unlist(theta) + s\n  #   }\n\n  interacao=list()\n  if(!is.null(theta_ini))\n    theta_ini= unlist(theta_ini,use.names = F)\n  if(is.null(theta_ini))\n    theta_ini= rep(1,length(theta))\n  theta_val = data.frame(matrix(theta_ini,nrow=1,dimnames = list(NULL,theta)))\n\n  k=1\n  dif=1\n  while(dif>parada & k <= max_it){\n    sigma=gerar_sigma(theta_val,data)\n    media=gerar_mu(theta_val,data)\n    Fn=gerar_F(theta_val,data)\n    Hn=gerar_H(sigma)\n    Sn=gerar_s(media,sigma,theta_val)\n\n    theta_val_novo = (solve(Matrix::t(Fn)%*%Hn%*%Fn,tol=1e-2000) %*% Matrix::t(Fn)%*%Hn%*%Sn)[,1]\n    names(theta_val_novo) = theta\n\n    interacao[[k]]=theta_val_novo\n    k=k+1\n    dif=sum(abs(theta_val-theta_val_novo)/theta_val)\n    theta_val[1,]=theta_val_novo\n\n    if(is.na(dif)) stop(\"Não convergiu\",call. = F)\n    \n    cat(paste0(\"Iteração \",k-1,\"\\n\"))\n    #cat(paste0(\"------ Dif = \",dif,\"\\n\"))\n    # cat(paste0(\"------ Residuo = \",mean(abs(resposta-gerar_mu(theta_val,data))),\"\\n\"))\n\n  }\n\n  estimado=theta_val_novo\n  if(bias_correction){\n    bias=correcao_vies()\n    theta_val[1,]=theta_val_novo-bias[,1]\n    theta_val_novo=unlist(theta_val[1,])\n    media=gerar_mu(theta_val,data)\n    sigma=gerar_sigma(theta_val,data)\n    Fn=gerar_F(theta_val,data)\n    Hn=gerar_H(sigma)\n    Sn=gerar_s(media,sigma,theta_val)\n    # saida=list(estimado=list(parameters=theta_val_novo, fitted=media, var=sigma),\n    #            corrigido=list(parameters=unlist(theta_val), fitted=media_bias, var=sigma_bias))\n    # class(saida) <- \"genReg\"\n    # return(saida)\n  }\n\n  if(k>max_it) stop(\"Não convergiu\",call. = F)\n\n  out <- list(\n    parameters=theta_val_novo,\n    fitted.values = media,\n    var = sigma,\n    funcao_mu = gerar_mu,\n    funcao_sigma = gerar_sigma,\n    matrizes = list(F=Fn,H=Hn,S=Sn),\n    data = data,\n    call = cl\n  )\n  class(out) <- \"genReg\"\n\n  return(out)\n  #return(list(estimado=tail(interacao,1),fitted=media))\n}\n\n#' @export\nsetClass(\"genReg\")\n\n\n#' @method print genReg\n#' @export\nprint.genReg <- function(x, ...){\n  cat(\"\\nCall:\\n\")\n  print(x$call)\n\n  ndec=stringr::str_length(stringr::str_extract(as.character(x$parameters), \"\\\\.[0-9]*\")) - 1\n\n  nround=(min(5,max(ndec)))\n  cat(\"\\n\\nCoefficients:\\n\")\n  print(round(x$parameters,nround))\n  cat(\"\\n\")\n}\n\n#' @method coef genReg\n#' @export\ncoef.genReg <- function(x, ...){\n  x$parameters\n}\n\n#' @method predict genReg\n#' @export\npredict.genReg <- function(x, newdata=NULL, ...){\n  if(is.null(newdata)) return(x$fitted.values)\n  x$funcao_mu(x$parameters,newdata,nrow(newdata))\n}\n",
    "created" : 1534193229868.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "238072835",
    "id" : "A275FB06",
    "lastKnownWriteTime" : 1540581227,
    "last_content_update" : 1540581227,
    "path" : "C:/Users/aperette/Desktop/Mestrado/pacote/geralReg/R/reg.R",
    "project_path" : "R/reg.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}